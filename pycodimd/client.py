import asyncio
import json
import os
import re

import requests
import websockets


class CodiMD:
    def __init__(self, server):
        self.login_cookies = None
        self.server_url = server
        self.socket = None
        self.next_edit_id = 0

    def login(self, username, password, type='email'):
        if type == 'email':
            username_arg = "email"
            login_url = "login"
        elif type == 'ldap':
            username_arg = "username"
            login_url = "auth/ldap"
        else:
            raise NotImplementedError()

        r = requests.post("{}/{}".format(self.server_url, login_url), data={
            username_arg: username,
            'password': password
        })
        self.login_cookies = r.cookies

    def default_cookie_file(self):
        HOME = os.environ['HOME']
        XDG_CONFIG_HOME = os.environ.get('XDG_CONFIG_HOME', HOME + '/.config')
        CODIMD_CONFIG_DIR = os.environ.get(
            'CODIMD_CONFIG_DIR', XDG_CONFIG_HOME + "/codimd")
        return os.environ.get(
            'CODIMD_COOKIES_FILE',
            CODIMD_CONFIG_DIR + "/key.conf")

    def save_cookies(self, filename=None):
        if not filename:
            filename = self.default_cookie_file()
        raise NotImplementedError()

    def load_cookies(self, filename=None):
        # Will load cookies from the file specified as the parameter. The
        # format is compatible with the cookie-jar generated by libcurl,
        # therefor also codimd-cli,
        if not filename:
            filename = self.default_cookie_file()

        cookies = {}
        with open(filename, 'r') as fp:
            for line in fp:
                if not re.match(r'^\# ', line):
                    try:
                        lineFields = line.strip().split()
                        cookies[lineFields[5]] = lineFields[6]
                    except IndexError:
                        # This happens on an empty line
                        continue

        self.login_cookies = cookies

    def history(self):
        r = requests.get("{}/history".format(self.server_url),
                         cookies=self.login_cookies)
        return json.loads(r.text)['history']

    def content(self, note_id):
        r = requests.get("{}/{}/download".format(self.server_url, note_id),
                         cookies=self.login_cookies)
        return r.text

    def import_note(self, note_id=None):
        raise NotImplementedError()

    def get_io_secret(self, note_id):
        r = requests.get(
            "{}/socket.io/?noteId={}&EIO=3&transport=polling".format(
                self.server_url,
                note_id),
            cookies=self.login_cookies)
        return r.cookies['io']

    def delete_line(self, note_id, line_num):
        content = self.content(note_id)
        lines = content.split('\n')

        selected_line = lines[line_num]

        length_line = len(selected_line) + 1  # +1, because of the \n
        length_before = 0
        length_after = -1  # -1, because the last line has no \n

        for line in lines[:line_num]:
            length_before += len(line) + 1  # +1, because of the \n

        for line in lines[line_num + 1:]:
            length_after += len(line) + 1  # +1, because of the \n

        asyncio.run(
            self.send_ws_edit(
                note_id, -length_line, length_before, length_after))

    def insert_line(self, note_id, line_num, line_content):
        content = self.content(note_id)
        lines = content.split('\n')

        length_before = -1
        length_after = 0

        for line in lines[:line_num]:
            length_before += len(line) + 1  # +1, because of the \n

        for line in lines[line_num + 1:]:
            length_after += len(line) + 1  # +1, because of the \n

        asyncio.run(
            self.send_ws_edit(
                note_id,
                line_content,
                length_before,
                length_after,
                True))

    def replace_line(self, note_id, line_num, line_content):
        self.delete_line(note_id, line_num)
        self.insert_line(note_id, line_num, line_content)

    async def socket_connect(self, note_id):
        secret = self.get_io_secret(note_id)

        uri = self.server_url.replace(
            'https',
            'wss') + "/socket.io/?noteId={}&EIO=3&transport=websocket&sid={}".format(
                note_id,
            secret)

        await self.socket_init(uri)

    async def socket_init(self, uri):
        self.socket = await websockets.connect(uri)

        await self.socket.send("2probe")
        message = await self.socket.recv()
        if message == "3probe":
            await self.socket.send("5")
            await self.socket.recv()

            await self.socket.send('42["user status",{"idle":false,"type":"lg"}]')
            msg = await self.socket.recv()
            self.next_edit_id = json.loads(msg[2:])[1]['revision']
            await self.socket.send("2")
            await self.socket.recv()
            await self.socket.recv()
            await self.socket.recv()

    async def send_ws_selection(self, note_id, anchor, head):
        if self.socket is None:
            await self.socket_connect(note_id)

    async def send_ws_edit(self, note_id, edit, char_before, char_behind, selection=False):
        if self.socket is None:
            await self.socket_connect(note_id)

        if isinstance(edit, int) and edit < 0:
            editlen = 0
        else:
            editlen = len(edit) + 1  # =1, because of the \n

        if selection:
            sel_anchor = str(char_before - 1)
            sel_head = str(char_before - 1)
            selection_string = '42["selection",{"ranges":[{"anchor":' + \
                sel_anchor + ',"head":' + sel_head + '}]}]'
            await self.socket.send(selection_string)

        id = str(self.next_edit_id)
        edit = str(edit) if isinstance(edit, int) else '"\\n' + str(edit) + '"'
        anchor = str(char_before + editlen)
        head = str(char_before + editlen)
        char_before = str(char_before)
        char_behind = str(char_behind)

        edit_string = '42["operation",' + id + ',[' + char_before + ',' + edit + ',' + \
            char_behind + '],{"ranges":[{"anchor":' + anchor + ',"head":' + head + '}]}]'

        await self.socket.send(edit_string)

        self.next_edit_id += 1
        await self.socket.close()
        self.socket = None

    def set_permission(note_id, permission="freely"):
        asyncio.run(_set_permission(note_id, permission="freely"))

    async def _set_permission(note_id, permission="freely"):
        secret = self.get_io_secret(note_id)
        uri = self.server_url.replace(
            'https',
            'wss') + "/socket.io/?noteId={}&EIO=3&transport=websocket&sid={}".format(
            note_id,
            secret)
        async with websockets.connect(uri) as websocket:
            await websocket.send("2probe")
            message = await websocket.recv()
            if message == "3probe":
                await websocket.send("5")
                await websocket.send('42["user status",{"idle":false,"type":"lg"}]')
                await websocket.send("2")
                await websocket.send('42["permission","{}"]'.format(permission))
